// This program implements the Groebner Basis Rewrite algorithm found in:
//
// “Formal verification of integer multipliers by combining grobner basiswith logic reduction”,
// 2016 Design, Automation Test in EuropeConference Exhibition (DATE)
//
// Algorithm 1 Grobner Basis Rewriting (GB-Rew)
//
// Input: Variables V, Circuit Model G notes: V is 
// Output: Model G_n rewritten wrt V
//  1. for g_i (belongs to) G do /* in reverse order of leading monomials */
//  2.    lv <- lm(g_i)
//  3.    r <- g_i - lv
//  4.    while Vars(r) (not set of) V do
//  5.        Choose v_t (belongs to) Vars(r)
//  6.        Choose g_t (belongs to) G st lm(g_t) = v_t
//  7.        r <- Spoly(r, g_t)
//  8.        r <- XOR-AND-Rule(r)
//  9.    end while
// 10.   g_i <- r + lv
// 11. end for
// 12. G_n <- UpdateModel(G, V) /* remove polynomials whoose leading terms are not in V */
// 13. return G_n
//
// Algorithm 2 Logic Reduction Rewriting
//
// Input: Specification Polynomial p_spec, Circuit Model G
// Output: Circuit Model G
// 1. V <- XORRewritingVariables(G)
// 2. G <- GB-Rew(V, G)
// 3. V <- CommonRewritingVariables(G)
// 4. G <- GB-Rew(V, G)
// 5. return G

// Import library for spoly function
LIB "teachstd.lib";
LIB "polylib.lib";

////////////////////
//// GATE TYPES ////
////////////////////

// z = ~a => g := -z + 1 - a
// z = a*b => g := -z + a*b
// z = a + b => g := -z + a + b - a*b
// z = XOR(a,b) => g := -z + a + b - 2*a*b

///////////////////
//// FUNCTIONS ////
///////////////////

// Use function to determine if polynomial expression represents an XOR gate and return variables
proc XOR_IDENT (poly g)
{
    ideal vars = variables(g);
    if (size(vars) != 3)
    {
        return(ideal());
    }
    else
    {
        int XOR_check = (g == -vars[1] + vars[2] + vars[3] -2*vars[2]*vars[3]);
        if (XOR_check)
        {
            return(vars);
        }
        else
        {
            return(ideal());
        }
    }
}

// Use function to determine is gate is an XOR gate and return logic 1 or 0
proc XOR_CHECK (poly g)
{
    ideal vars = variables(g);
    if (size(vars) != 3)
    {
        return(0);
    }
    else
    {
        return(g == -vars[1] + vars[2] + vars[3] -2*vars[2]*vars[3]);
    }
}

// Use function to determine if polynomial is an AND gate and return variables
proc AND_IDENT (poly g)
{
    ideal vars = variables(g);
    if (size(vars) != 3)
    {
        return(ideal());
    }
    else
    {
        int AND_check = (g == -vars[1] + vars[2]*vars[3]);
        if (AND_check)
        {
            return(vars);
        }
        else
        {
            return(ideal());
        }
    }
}

// Use function to determine if polynomial is an AND gate and return logic 1 or 0
proc AND_IDENT (poly g)
{
    ideal vars = variables(g);
    if (size(vars) != 3)
    {
        return(0);
    }
    else
    {
        return(g == -vars[1] + vars[2]*vars[3]);
    }
}

// Use function to determine if polynomial is an INV gate and return logic 1 or 0
proc INV_CHECK (poly g)
{
    ideal vars = variables(g);
    if (size(vars) != 2)
    {
        return(0);
    }
    else
    {
        return(1);
    }
}

// Determines if r shares variables contained in ideal V
proc VARS_NOT_IN_V (poly r, ideal V)
{
    int size_g = size(variables(r));
    int size_V = size(V);
    intvec logic; 
    for (int i = 1; i <= size_g; i = i + 1)
    {
        for (int j = 1; j <= size_V; j = j + 1)
        {
            logic = logic + (variables(r)[i] == variables(V)[j]);
        }
    }
    int result;
    if (logic != size_g)
    {
        result = 1;
    }
    else
    {
        result = 0;
    }
    return(result);
}

proc CHOOSE_VT (poly r, ideal V)
{
    int size_g = size(variables(r));
    int size_V = size(V);
    intvec logic;
    for (int i = 1; i <= size_g; i = i + 1)
    {
        for (int j = 1; j <= size_V; j = j + 1)
        {
            logic = logic + (variables(r)[i] == variables(V)[j]);
        }
        if (logic == 1)
        {
            return(variables(r)[i]);
            break;
        }
    }
    return(0);
}

// Finds gt in G such that leadmonom(gt) = vt
proc CHOOSE_GT (poly vt, ideal G)
{
    int size_G = size(G);
    for (int i = 1; i <= size_G; i = i + 1)
    {
        if (vt == leadmonom(G[i]))
        {
            return(G[i]);
        }
    }
    return(0);
}

// Used between steps to ensure variable with powers greater than 1 are reduced to 1
proc POWER_REDUCE (poly r)
{
    ideal monomials;
    poly lv;
    number lc;
    while(1)
    {
        lv = leadmonom(r);
        lc = leadcoef(r);
        monomials = monomials, lc*lv;
        r = r - lc*lv;
        if (r != 0)
        {
            continue;
        }
        else
        {
            break;
        }
    }
    poly r_reduced;
    int i_max = ncols(monomials);
    for (int i = 2; i <= i_max; i = i + 1)
    {
        int size_vars = size(variables(monomials[i]));
        int maxdeg_mon = maxdeg(monomials[i]);
        if (size_vars != maxdeg_mon)
        {
            for (int j = 1; j <= size_vars; j = j + 1)
            {
                poly v = variables(monomials[i])[j];
                poly p = v^2 - v;
                monomials[i] = spoly(monomials[i], p);
            }
        }
        r_reduced = r_reduced + monomials[i];
    }
    return(r_reduced);       
}

// Repeats Spoly until vt is removed from r
proc SPOLY_REPEAT (poly vt, poly r, poly gt)
{
    int INV_check = INV_CHECK(gt);
    if (INV_check)
    {
        gt = gt -  1;
    } 
    ideal monomials;
    poly lv;
    number lc;
    while(1)
    {
        lv = leadmonom(r);
        lc = leadcoef(r);
        monomials = monomials, lc*lv;
        r = r - lc*lv;
        if (r != 0)
        {
            continue;
        }
        else
        {
            break;
        }
    }
    poly r_new;
    poly poly_monomial;
    int i_max = ncols(monomials);
    for (int i = 2; i <= i_max; i = i + 1)
    {
        poly_monomial = monomials[i];
        ideal poly_vars = variables(poly_monomial);
        number poly_sign = leadcoef(poly_monomial);
        int num_vars = size(poly_vars);
        int logic = 0;
        for (int j = 1; j <= num_vars; j = j + 1)
        {
            logic = logic + (vt == poly_vars[j]);
        }
        if (logic != 0) //vt exists in term
        {
            if (INV_check and (num_vars > 2))
            {
                poly vars_add = poly_vars[2];
                for (k = 3; k <= num_vars; k = k + 1)
                {
                    vars_add = vars_add * poly_vars[k];
                }
                poly_monomial = spoly(poly_monomial, gt) + poly_sign * vars_add;
            }
            if (INV_check)
            {
                poly_monomial = spoly(poly_monomial, gt) + poly_sign * poly_vars[2];
            }
            else
            {
                poly_monomial = spoly(poly_monomial, gt);
            }
            poly_monomial = POWER_REDUCE(poly_monomial);
        }
        r_new = r_new + poly_monomial;
    }
    return(r_new);
}

// proc identify monomials that are multiplied together,
// check function used in power reduce, max degree
proc find_multipliers(poly g)
{
  list v;
  int v_ind = 1;
  int i_size = size(g);
  for(int i = 1; i <= i_size; i = i + 1)
  {
    if(maxdeg(g[i]) > 1)
    {
      v[v_ind] = g[i];
      v_ind = v_ind + 1;
    }
  }
  return(v);
}

// proc to search for
proc find_matching(poly f, poly g, ideal G)
{
  poly f1 = CHOOSE_GT(f, G);
  poly g1 = CHOOSE_GT(g, G);
  if(XOR_CHECK(f1) && AND_CHECK(g1))
  {
    ideal f1_vars = XOR_IDENT(f1);
    ideal g1_vars = AND_IDENT(g1);
    if(f1_vars[2] == g1_vars[2] && f1_vars[3] == g1_vars[3])
    {
      return(1);
    }
  }
  else
  {
    if(XOR_CHECK(g1) && AND_CHECK(f1))
    {
      ideal f1_vars = AND_IDENT(f1);
      ideal g1_vars = XOR_IDENT(g1);
      if(f1_vars[2] == g1_vars[2] && f1_vars[3] == g1_vars[3])
      {
        return(1);
      }
    }
  }
  //May want to update this to actually check deeper, but this should be good for now
  return(0);
}

proc XOR_AND_RULE (poly g, ideal G)
{
  list l = find_multipliers(g);
  int l_size = size(l);
  poly f = g;
  for(int i = 1; i <= l_size; i = i + 1)
  {
    ideal vs = variables(l[i]);
    int var_size = size(vs);
    for(int j = 1; j <= var_size; j = j + 1)
    {
      for(int k = j + 1; k <= var_size; k = k + 1)
      {
        if(find_matching(vs[j], vs[k], G))
        {
          f = f - l[i];
          break;
        }
      }
    }
  }
  return(f);
}

proc V_XOR (ideal G, ideal primary)
    ideal V;
    ideal XOR_vars;
    int size = ncols(G);
    for (int i = 1; i <= size; i = i + 1)
    {
        XOR_vars = XOR_vars + XOR_IDENT(G[j]);
    }
    V = XOR_vars, primary;
    return (V);
}

proc GB_REW (ideal G, ideal primary)
    ideal V = V_XOR (G, primary);
    int size = ncols(G);
    for (int i = size; i >= 1; i = i - 1)
    {
        poly lv = leadmonom(G[i]);
        number lc = leadcoef(G[i]);
        poly r = G[i] - lc*lv;
        while (VARS_NOT_IN_V(r, V))
        {
            poly vt = CHOOSE_VT(r, V);
            poly gt = CHOOSE_GT(vt, G);
            r = spoly(r, gt);
            r = POWER_REDUCE(r);
            r = XOR_AND_RULE(r);
        }
        G[i] = r + lc*lv;
    }
    return(G);
    // need update model still
}